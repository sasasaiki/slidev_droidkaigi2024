---
# You can also start simply with 'default'
theme: seriph
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
background: https://cover.sli.dev
# some information about your slides (markdown enabled)
title: Welcome to Slidev
info: |
  ## Slidev Starter Template
  Presentation slides for developers.

  Learn more at [Sli.dev](https://sli.dev)
# apply unocss classes to the current slide
class: text-center
# https://sli.dev/custom/highlighters.html
highlighter: shiki
# https://sli.dev/guide/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/guide/syntax#mdc-syntax
mdc: true
---


---
layout: default
---

# 表紙

始めたいと思います、よろしくお願いします。

---
layout: default
---

# 自己紹介

ウンタラカンタラ

---
layout: default
---

# 目次

ウンタラカンタラ

---
layout: default
---

# 今日作るもの

では初めて行きましょう。
今日は、使って知るCustomLayoutということで、何も知らない状態から、ちょっとしたCustomLayoutを作ルことで、理解を深めていきます。

何を作るかというと、こちらです。
カレンダーアプリとかでよくWeeklyとかで表示されるうちの一日分を作っていきます。
このSession内ではDailySchedulerと呼ぶことにします。

具体的には
- 時刻に合わせた縦軸表示  
- 時刻と対応したイベントの配置・サイズの調整  
- 同時刻に複数イベントがあった際の幅の調整  
- イベントのドラッグ&ドロップ
- 時刻へのスナッピング  
- 遅延Redering  

---
layout: default
---

# CostomLayoutとは

ちょっと最初に謝らなければいけないんですが、ComposeにCustomLayoutという関数はありません。
なので今日の話は、厳密にはCostomLayoutを作成するためのLayout関数の話になります。
https://developer.android.com/develop/ui/compose/layouts/custom


じゃあこのLayout関数がどういうものなのかを知るために、まず毎度お馴染みのcoposeの3Stepを確認する必要があります。


---
layout: default
---
耳にタコでしょうね
# composeのサンステップ

composition

layout

draw

があります

compositionはインスタンスを作る

Columnとかで例に出す

layout、
子要素のサイズを測定して配置して自分のサイズを確定する

Columnでは自動でやってくれる
offsetの例

draw 描画
drawabackgroundの例


Layout関数はこのLayout部分を自分で実装するという話になります。

---
layout: default
---

# 少し詳しく

例えばColmunもこの関数を使って作られています。
こんな感じで重ならないように順番に置きますよーとあります。

なので、半分重なるように置きたいんだ！
みたいな場合にこのLayout部分をいじることで、実現できます。
ずらすだけなので、offsetつければいけるかも、と思ったりするんですが、Colmunでやろうと思っても、compositionのタイミングではTextの高さがわからないので、できません。
なのでLayoutフェーズで高さを測定してから、位置を決めて配置する必要があります。


ちなみに、ここを半分重なる、ではなく10dp重ねたいんだ！とする場合はLayout使わず可能ですね。


---
layout: default
---

# Layout関数以外の選択肢

- subcomopseLayout
- BoxWithConstraint
- Modifier.layout

などがあります。

これはそれぞれこう・こう・こうという感じになりますので、用途に合わせて選びましょう。

今回は複数の要素があって、カレンダーのイベントは必ず配置するんだけど長さと位置が変わるだけということでLayoutを利用します。

上からここまで5分




-------------------------------------------


---
layout: default
---

# 時刻の配置

まずは時刻を配置しながら、Layoutの基本を学んでいきます。

正直Layoutの使い方に関してはここだけで大体わかります。

さて、まずは要素と並びを確認します。

すごくシンプルで、時刻があって、その時刻が一定の間隔で並びます。

時刻があって、一時間分の間隔でまた時刻がある、それを時刻の分だけ繰り返します。

では、実際のコードを考えていきます。

まずはお馴染みのComposableでLayout、ここでは一応ユーザーの好きなlabelを渡せるようにしておきます。

そして、ラベルを時刻分だけ作成し、Layoutに渡します。
こうすることでこのComposeがLayoutにmeasurableとして入ってくるようになります。（表現として正しいかは微妙です）

widthやheightはpxなので注意する必要があります。

ではいよいよLayoutフェーズをゴニョゴニョしていきましょう。

ここでの登場人物はまずmeasurableとconstraints

mesurableがconstraintを使って要素のサイズを計ります。

// TODO
constraintっていうのは親の制約が入ってきます。（具体的な例を出す）

// TODOちゃんとした表現
mesurableが何かと言われるとちょっとわからんのですが、まあ対応するcomposeのサイズ測定するためのクラスですね多分。

// TODO深掘り
このようなコードで計り、その結果が今度はPlaceableに入ってきます。
Placeableからは測定した高さや幅が取れるので、これを使って今度は配置を決めていきます。

今回はよこは渡したラベルのテキストはば、縦は固定値で入れたいので、縦のminheit,maxheitに固定の高さを入れます。
この固定値は結構よく使うので、miniutHeightとしてdpで定義して、pxで持っておきます。

// TODO このような場合はテキストのサイズになり、fillMaxならマックスになる。親の制約を受ける。みたいな話を言いたい

最後にlayoutします。

offsetを指定できます左上が0,0なので下に動かしたければoffsetYを+に指定します。右に動かしたければoffsetXを+に指定します。

offsetは高さ* indexにになるので単純に足していきます。

はい、こんな感じで特に難しいことはなく、できましたね。これができれば基本は大体抑えられていると思うのでご安心ください。

2分


---
layout: default
---

# 時刻に合わせた縦軸表示


// TODO 動画かページ見て確認
線を引くのには二つ考えられる方法があって、一つはラベルの背景としてかく、もう一つはdividerとして置くです。
どちらかというと多分背景として書く方がコストは安く済むと思うのですが、今回はdividerとしておいています。

そうしておくと、例えば点線にしたいとか、ピンクにしたいとか、そう言うユーザーのニーズに応えやすいので、それはそれで良いかなと思います

先ほど、時刻ラベルを渡したのと同様にdeviderも渡していきます。

//TODO調べる
ここでワンポイントなんですが、Layout関数にContentsとしてListのListを受け取るものとContentを受け取るものがあり、後者の場合は全てひらのリストで渡されますが、前者の場合はこんな感じでlistのリストで受け取れるので、渡すcompoeseが複数種類ある場合はこちらを使う方が都合がいいです。


では見てみましょう。
これはすごく簡単で、測定したあと、時効と同じ位置におけばokです。

1分

---
layout: default
---

# 時刻と対応したイベントの配置・サイズの調整  

さて、いよいよイベントを置いていきます。

まずはイベントのデータ構造を考えていきます。

とりあえず表示に必要な最低限の情報としては
start
end
id
があれば置くことが可能です。
タイトルとか、詳細とかは見た目の問題なので、ユーザーが使いたければ定義して使えるようにと言うことで、とりあえずこれらをinterfaceとして定義します。　(TODO 冗長かもね)

イベントのリストから、ebentのcomposeを同じだけ作って渡します。

これでLayoutの中でサイズを時間の長さに合わせて、開始位置をlabelの位置と合わせればよいのですがここで一つ問題があります。
入ってきたmesurabeはeventの情報を持っていないと言うことです。

開始時刻と終了時刻を知りたいなあと思っても取ってくることができません。

そこで
- ParentDataModifier
を使います。

これを利用することで、任意のdataをparentに伝えることが可能です。

使い方は結構簡単で

こんな感じで定義して

modifierに追加します。

これで、このようにdataを取ってくることが可能です。

そうすれば、開始と終了が取れます。

では、まず高さを開始と終了時刻から計測します。

今回は高さを指定したいので、まずは単純に高さを計算します。
そしてmaxでもminでもこの高さですよ、と制限を変更して、測定します。

これでこうなります。

あとは一を自国にそろえます。

やりました。

1.5分


---
layout: default
---

# 同時刻に複数イベントがあった際の幅の調整

さて、次はこういう状態ですね。

1,重なりのあるイベントをグルーピング
2,グループのかずに合わせて幅を調整
3,グループ内の位置に合わせてxOffsetを調整

1に関してはCustomLayoutあんまり関係ないんで軽くなんですが。

まずはGeminiに聞いてgroupingするコードを書いてもらいます

プロンプトはこんな感じで適当に聞いたんですが、普通に動くコードを出してくれました。これ多分自分じゃ描けなかったので本当に助かりましたね。
 
> List< CalendarEvent >があった時、 時間的に重なりがあるEventをグルーピングする処理をKotlinで書いて


いくつか試したり、テストしたりして、今回は一部間違っていたので修正して、重なりがあるeventごとにlistのlistにしてみました。

で、データに、自分が何人のグループの何番目のアイテムなのか、を追加で持たせます。
layoutのタイミングで幅と位置を知る必要があるためです。

これで準備完了です。

ちなみにこれはlayoutのラムダの中でやってもいいように見えますが、そうするとcompositionは走らないがlayoutが走るような場合、次にやるイベントをドラッグしている時とかですね、にも処理が走ってしまって無駄なので、今回のケースではcompositionの方でやっています。

ドラッグに合わせてここの表示も更新する場合はlayoutでやる必要があるかもしれません。

あとは特に特別なことはなくて、幅を制限して測定して、xをpositionに合わせて配置するだけで完成です。

1.5

---
layout: default
---

#  イベントのドラッグ&ドロップ

さて、つづいが結構悩ましそうなドラッグ＆ドロップの実装です。

この動きですね。

思いつく方針としては、二つありました

1. 各イベントアイテムにDraggableをつけてそれぞれでドラッグを管理する
2. カスタムViewにpointerInputをつけて管理する

今回は1を選択しました。
1の方が簡単そうだったからですね。
2だとドラッグの開始位置からどのイベントをドラッグするのかを計算する必要があってそれがなんとなくめんどくさそうだったためです。
ドラッグでもっと色々な動きを、入れ替えとかするのであれば2の方針も検討する必要がありそうです。

では具体的な実装を見てみましょう

事前準備として、ドラッグしたアイテムのY位置のオフセットを大元のcomposeに持たせます。
 
<!-- var draggingItemYOffset: Float by remember {  
    mutableFloatStateOf(0f)  
} -->

そして、各イベントにはドラッグ状態を表すisDraggingを持たせます。

offsetを各イベントに持たせず大元に持たせるのは、ここの値はdrag中に頻繁に書き換えるため、リストの中のアイテムのパラメータとして持たせると更新に多少コストがかかりそうだと思ったからです。おそらくよほどアイテムの量が多くなければ中に持たせても特に問題はないとは思います。
逆にdragg中のイベントがどれかという情報を大元にもたせなかったのは、drag中はイベントの色を変えるなど、各イベントcomponentで見た目を変更する際に参照したかったからです。
// TODO isDragも持たせればいいのでは？

やることは結構簡単で、まず、ebentにDraggableをつけます。

// TODOcode

中身はこんな感じで、ドラッグ開始でドラッグをtrueにする、endでfalseにする。
そして、移動のたびにyOffsetを更新します。

そして、Layoutのblockの中でもしtrueだった場合に、offSetぶんずらしてやるようにしていきましょう。

こんな感じになります。
// CODE

ここで、一つ大事なことがあります。

移動中にyOffSetが更新し続けられるのですが、これをreadしているところはlayoutのblock内だけなので、理論的にはCompositionのフェーズをスキップしてlayoutとドローのフェイズのみ実行させることができそうですよね。

ただ、実際にやってみると、こんな感じでドラッグ中に動かしているアイテム以外もcompositionが走ってしまいます。
// TODO動画

これは、composeにこのListが安定していないとみなされている、skipできていない状態になっています。

そこでですね、こちらの手順を踏んで、Listは安定しているんだと教えてあげると、無事スキップされるようになります。

知らないとそのままにしてしまうところではあるよなあと思ったので是非今日はここだけでも覚えて帰っていただければと思います。

さて、ドラッグの話に戻ります。

あとはですね、isDragを見て、見た目もこんな感じに半透明にするとかやってあげれば完成です。

ドラッグが終わったタイミングで大抵eventの更新をリポジトリなどを通してすることがあるのでonFinishのイベントを発生させる必要があるのですが、それはスナッピングの後に考えてみましょう。


4--
layout: default-
---
分
# 時刻へのスナッピング  

次はスナッピングですね。

この動きですね。今回は5の倍数の分にスナップしてみます

やることは簡単で、ドラッグ中は単純にoffsetを反映した位置ではなく一番近い5で割れるふんの位置に起くだけです。

なので、まずはgeminiに聞きます

こんな感じで聞くと

まあロジックを書いてくれるので、あってるかなあっていうのを読んでまああってそうだったので使います。

これで一番近い置き場所がわかるので、あとは、まず時から位置を取ってきて、その後一番近いふんの分だけoffsetを足してやります。

そしてあとはおく。と。

これでokです

ついでに先ほど実装しなかったドラッグが終わったイベントを発行しましょう。

ドラッグが終わった時に、ドラッグされたイベントが何時何分に移動されたかは、このlayoutblockの中でしかまだわからないので、onDragFinishで使えるように外に値を反映してやる必要があります。

eventItemに持たせるか、親のこんぽーずにもたせるかどっちでもやれるのですが、今回は親のコンポーズに持たせてみます。パフォーマンスの点で少し部があるためです。

というのも、layoutBlockではdragがいつ終わったかは検知できないので、普通にやるとdragのたびにイベントを更新することになり、それによってcompositionが入るため、若干コストがかかります。
一方、親で持ってその値を使う場合は、readがonFinishのタイミングのみになりますから、ドラッグ中は相変わらずComposeitionが走りません。

ということで、やってみます。

こんな感じでできそうですが、実際に動かしてみると、値が更新されていません。

これもCustomLayoutに限らないポイントなんですが、Listenerの中でstateをみている場合はUpdatedStateを使わないと最新の値がつかわれないのでご注意ください。

ということで、UpdatedStateを使い無事通知されました。
compositionも走っていませんね。

2分


---
layout: default
---

# 遅延Redering  

いよいよ最後に遅延レンダリングです。
最初に言っておくと、結構力技で無理やりやっているので、流石にもうちょっとマシなやり方あるだろうという感じではあるのですが、参考程度に聞いていただければと思います。

正直デイリーのカレンダーで遅延レンダリングを必要とすることって普通ないとは思うんですが、それだとモチベーションも湧かないので今回は365日分を縦に並べてみようと思います。

単純に365日表示してみると、しっかりアウトオブメモリでクラッシュします。（久しぶりに見た）

これを表示して、スクロールできるように頑張ってみます。

とりあえず遅延レンダリングといえばLazy系のComposeでしょうということでLayColmunを読んでみたんですが、難しくてよくわからない上に最終的にSubComposeLayoutを使っていました。

確かに、表示しないところはそもそもCoposeを配置しないというのが正しいのでSubComposeLayoutを使うと良さそうではあるのですが、今回はどうしてもLayoutで済ませたいのでLayoutでできないかを考えてみます。

SubComposeLayoutを使う必要があるケースとしてはlayoutフェーズで測定するまでどの要素を配置すべきかが確定しないケースがあります。Lazy系のものはまさにそれで、ユーザーが渡してくるcomposeによってアイテムのサイズが変わるため、何個配置すべきかが測定するまでわからないので、SubComposeLayoutでないと実現が難しそうです。
一方で今回の我々のケースでは、中のアイテムのサイズは時刻と固定値にって計算できるのでLayoutより前に決められます。
つまり、Layoutでも、必要な分だけComposeを渡すということができそうですね。
パフォーマンスの懸念はありそうですが、とりあえずやってみます。

手順としては、

viewPortから画面に表示できる個数を計算する
scrollのoffsetから今表示したいindexを計算する
indexと個数から今表示したい時刻を決める
表示する時刻から表示するeventを決める
今まで通りの処理に渡す

こんな感じです。


やる

やる
やる

やる



これで、実行してみると、スクロールができました！

スクロールのたびにcomposeが走るのでちょっとスムーズではないのですが、リリースビルドだと何もわからないレベルで高速スクロールが可能な程度には動きました。

もう一つ別の方針で試したことがあって、これはcomposeは全て渡すけど必要なところ以外はレイアウトしない、というようなことをやってみました。

一応動いたんですがこっちの方が目に見えてカクツクのと、一度レイアウトしたcompseは残るようで、スクロールすればするほど目に見えないcompsoeが増える怖い挙動になるため、やめた方が良さそうです。

3分+コードで1分




















